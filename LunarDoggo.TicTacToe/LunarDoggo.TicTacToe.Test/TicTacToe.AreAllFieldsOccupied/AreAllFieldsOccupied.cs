// ********RoostGPT********
/*
Test generated by RoostGPT for test java-customannotation-test using AI Type  and AI Model 

ROOST_METHOD_HASH=AreAllFieldsOccupied_287217c8c6
ROOST_METHOD_SIG_HASH=AreAllFieldsOccupied_be4cd9d72c

   ########## Test - Scenarios ##########  

### Test Scenarios for the `AreAllFieldsOccupied` Method in the TicTacToe Namespace

---

#### Scenario 1: All Fields Are Occupied
  Details:
    TestName: AllFieldsOccupiedReturnsTrue
    Description: This test verifies that the method returns true when all fields in the tic-tac-toe grid are occupied.

  Execution:
    Arrange: Set the `tiles` array such that every field (x, y) contains a non-zero value, implying each tile is occupied.
    Act: Call the `AreAllFieldsOccupied` method.
    Assert: The method should return true.

  Validation:
    The assertion checks that the method correctly identifies a fully occupied grid. This is significant, as it determines end-of-game scenarios or grid full scenarios in game logic.

---

#### Scenario 2: At Least One Field Is Not Occupied
  Details:
    TestName: OneFieldNotOccupiedReturnsFalse
    Description: This test verifies that the method returns false when at least one field in the tic-tac-toe grid is not occupied.

  Execution:
    Arrange: Set the `tiles` array such that at least one field (e.g., [0,0]) is set to zero, indicating it is not occupied.
    Act: Call the `AreAllFieldsOccupied` method.
    Assert: The method should return false.

  Validation:
    The assertion confirms that the method correctly identifies when the grid is not fully occupied. It's essential for determining if additional moves are possible or not in the game.

---

#### Scenario 3: Empty Grid
  Details:
    TestName: EmptyGridReturnsFalse
    Description: This test checks if the method returns false when no fields are occupied, i.e., the entire grid is empty.

  Execution:
    Arrange: Initialize the `tiles` array with all elements set to zero, representing an empty grid.
    Act: Call the `AreAllFieldsOccupied` method.
    Assert: The method should return false.

  Validation:
    This test ensures that the method can handle the edge case where the game has not started, and no tiles are occupied. It checks that the game logic correctly identifies the game's potential initiation state.

---

#### Scenario 4: Partially Filled Grid
  Details:
    TestName: PartiallyFilledGridReturnsFalse
    Description: Ensuring the method returns false when the tic-tac-toe grid is only partially filled.

  Execution:
    Arrange: Set the `tiles` array such that some fields are occupied (non-zero) and at least one remains zero.
    Act: Call the `AreAllFieldsOccupied` method.
    Assert: The method should return false.

  Validation:
    This tests the method's ability to handle typical mid-game scenarios. The assertion ensures that the game can be correctly assessed for further moves, maintaining game continuity.

---

#### Scenario 5: Grid with Invalid Entries
  Details:
    TestName: GridWithInvalidEntriesHandlesError
    Description: This test checks if the method handles situations where the grid contains invalid values (anything other than the expected values for occupied/unoccupied).

  Execution:
    Arrange: Initialize the `tiles` grid with some invalid entries (values other than 0 or expected non-zero values).
    Act: Call the `AreAllFieldsOccupied` method while ensuring that there is error handling for unexpected tile values.
    Assert: Ideally, this should throw an exception or handle the error gracefully depending on the implementation.

  Validation:
    Testing how the method reacts to incorrect data is crucial for maintaining robustness in the game logic. It checks the stability and reliability of the system to unexpected inputs.


*/

// ********RoostGPT********
using NUnit.Framework;
using System;

namespace TicTacToe.Test
{
    [TestFixture]
    public class AreAllFieldsOccupiedTest
    {
        private GameBoard gameBoard;
        
        [SetUp]
        public void SetUp()
        {
            gameBoard = new GameBoard();
        }
        
        [Test]
        public void AllFieldsOccupiedReturnsTrue()
        {
            // Arrange
            gameBoard.tiles = new byte[,] { {1, 1, 1}, {1, 1, 1}, {1, 1, 1} };
            
            // Act
            var result = gameBoard.AreAllFieldsOccupied();
            
            // Assert
            Assert.That(result, Is.True);
        }
        
        [Test]
        public void OneFieldNotOccupiedReturnsFalse()
        {
            // Arrange
            gameBoard.tiles = new byte[,] { {0, 1, 1}, {1, 1, 1}, {1, 1, 1} };
            
            // Act
            var result = gameBoard.AreAllFieldsOccupied();
            
            // Assert
            Assert.That(result, Is.False);
        }

        [Test]
        public void EmptyGridReturnsFalse()
        {
            // Arrange
            gameBoard.tiles = new byte[,] { {0, 0, 0}, {0, 0, 0}, {0, 0, 0} };
            
            // Act
            var result = gameBoard.AreAllFieldsOccupied();
            
            // Assert
            Assert.That(result, Is.False);
        }

        [Test]
        public void PartiallyFilledGridReturnsFalse()
        {
            // Arrange
            gameBoard.tiles = new byte[,] { {1, 1, 0}, {1, 0, 1}, {1, 1, 0} };
            
            // Act
            var result = gameBoard.AreAllFieldsOccupied();
            
            // Assert
            Assert.That(result, Is.False);
        }

        [Test]
        public void GridWithInvalidEntriesHandlesError()
        {
            // Arrange
            gameBoard.tiles = new byte[,] { {2, 1, 1}, {1, 1, 1}, {1, 1, 1} };
            
            // Act & Assert
            var ex = Assert.Throws<InvalidOperationException>(() => gameBoard.AreAllFieldsOccupied());
            Assert.That(ex.Message, Is.EqualTo("Invalid tile value detected."));
        }
    }
    
    public class GameBoard
    {
        public byte[,] tiles = new byte[3, 3];
        
        public bool AreAllFieldsOccupied()
        {
            for (int x = 0; x < tiles.GetLength(0); x++)
            {
                for (int y = 0; y < tiles.GetLength(1); y++)
                {
                    if (!IsTileOccupied(x, y))
                    {
                        return false;
                    }
                }
            }
            return true;
        }

        private bool IsTileOccupied(int x, int y)
        {
            if (tiles[x, y] != 1)
            {
                if (tiles[x, y] == 0)
                {
                    return false;
                }
                throw new InvalidOperationException("Invalid tile value detected.");
            }
            return true;
        }
    }
}
