// ********RoostGPT********
/*
Test generated by RoostGPT for test artilleryTest using AI Type  and AI Model 

ROOST_METHOD_HASH=OccupyTile_9e22e63103
ROOST_METHOD_SIG_HASH=OccupyTile_73b7c8d7ca

   ########## Test-Scenarios ##########  

Scenario 1: OccupyTile should occupy the tile if it is not already occupied.

Details:
  TestName: OccupyTile_OccupyTileIfNotOccupied
  Description: Ensure that the method occupies the tile if it is not already occupied.
  Execution:
    Arrange: Create a game state object and a button tile mapping object with a button that is not occupied.
    Act: Call the OccupyTile method with the button tile mapping.
    Assert: Verify that the tile is occupied by the current player.
  Validation:
    This test is important to ensure that the method correctly occupies a tile that is not already occupied. It verifies the basic functionality of the method.

Scenario 2: OccupyTile should not occupy the tile if it is already occupied.

Details:
  TestName: OccupyTile_DoNotOccupyTileIfOccupied
  Description: Ensure that the method does not occupy the tile if it is already occupied.
  Execution:
    Arrange: Create a game state object and a button tile mapping object with a button that is already occupied.
    Act: Call the OccupyTile method with the button tile mapping.
    Assert: Verify that the tile is not occupied by the current player.
  Validation:
    This test is important to ensure that the method does not occupy a tile that is already occupied. It checks the error handling of the method.

Scenario 3: OccupyTile should switch players if the tile is successfully occupied.

Details:
  TestName: OccupyTile_SwitchPlayersIfTileOccupied
  Description: Ensure that the method switches players if the tile is successfully occupied.
  Execution:
    Arrange: Create a game state object and a button tile mapping object with a button that is not occupied.
    Act: Call the OccupyTile method with the button tile mapping.
    Assert: Verify that the current player is switched to the other player.
  Validation:
    This test is important to ensure that the method correctly switches players after successfully occupying a tile. It verifies the player switching functionality of the method.

Scenario 4: OccupyTile should invoke GameOverPlayerWon event if the current player has won.

Details:
  TestName: OccupyTile_InvokeGameOverPlayerWonIfPlayerWon
  Description: Ensure that the method invokes the GameOverPlayerWon event if the current player has won.
  Execution:
    Arrange: Create a game state object and a button tile mapping object with a button that, when occupied, will result in the current player winning.
    Act: Call the OccupyTile method with the button tile mapping.
    Assert: Verify that the GameOverPlayerWon event is invoked with the current player as the winner.
  Validation:
    This test is important to ensure that the method correctly triggers the GameOverPlayerWon event when the current player wins the game. It tests the win condition handling of the method.

Scenario 5: OccupyTile should invoke GameOverDraw event if all fields are occupied and no player has won.

Details:
  TestName: OccupyTile_InvokeGameOverDrawIfAllFieldsOccupied
  Description: Ensure that the method invokes the GameOverDraw event if all fields are occupied and no player has won.
  Execution:
    Arrange: Create a game state object and a button tile mapping object with buttons that, when occupied, will result in all fields being occupied.
    Act: Call the OccupyTile method with the button tile mappings to occupy all fields.
    Assert: Verify that the GameOverDraw event is invoked.
  Validation:
    This test is important to ensure that the method correctly triggers the GameOverDraw event when all fields are occupied and no player has won. It tests the draw condition handling of the method.

Scenario 6: OccupyTile should invoke TileAlreadyOccupied event if the tile is already occupied.

Details:
  TestName: OccupyTile_InvokeTileAlreadyOccupiedIfTileOccupied
  Description: Ensure that the method invokes the TileAlreadyOccupied event if the tile is already occupied.
  Execution:
    Arrange: Create a game state object and a button tile mapping object with a button that is already occupied.
    Act: Call the OccupyTile method with the button tile mapping.
    Assert: Verify that the TileAlreadyOccupied event is invoked.
  Validation:
    This test is important to ensure that the method correctly triggers the TileAlreadyOccupied event when the tile is already occupied. It tests the error handling of the method.


*/

// ********RoostGPT********
using NUnit.Framework;
using System;

namespace TicTacToe.Test
{
    [TestFixture]
    public class OccupyTile412Test
    {
        private GameState gameState;
        private ButtonTileMapping[] buttonTileMappings;

        [SetUp]
        public void Setup()
        {
            buttonTileMappings = new ButtonTileMapping[]
            {
                new ButtonTileMapping(new Button(), 0, 0),
                new ButtonTileMapping(new Button(), 1, 0),
                new ButtonTileMapping(new Button(), 2, 0),
                new ButtonTileMapping(new Button(), 0, 1),
                new ButtonTileMapping(new Button(), 1, 1),
                new ButtonTileMapping(new Button(), 2, 1),
                new ButtonTileMapping(new Button(), 0, 2),
                new ButtonTileMapping(new Button(), 1, 2),
                new ButtonTileMapping(new Button(), 2, 2)
            };

            gameState = new GameState(buttonTileMappings);
        }

        [Test, Category("valid")]
        public void OccupyTile_OccupyTileIfNotOccupied()
        {
            // Arrange
            ButtonTileMapping mapping = buttonTileMappings[0];

            // Act
            gameState.OccupyTile(mapping);

            // Assert
            Assert.AreEqual(gameState.CurrentPlayer, gameState.FirstPlayer);
            Assert.IsTrue(gameState.GameBoard.IsTileOccupied(mapping.TileX, mapping.TileY));
        }

        [Test, Category("valid")]
        public void OccupyTile_DoNotOccupyTileIfOccupied()
        {
            // Arrange
            ButtonTileMapping mapping = buttonTileMappings[0];
            gameState.OccupyTile(mapping);

            // Act
            gameState.OccupyTile(mapping);

            // Assert
            Assert.AreEqual(gameState.CurrentPlayer, gameState.FirstPlayer);
            Assert.IsTrue(gameState.GameBoard.IsTileOccupied(mapping.TileX, mapping.TileY));
        }

        [Test, Category("valid")]
        public void OccupyTile_SwitchPlayersIfTileOccupied()
        {
            // Arrange
            ButtonTileMapping mapping = buttonTileMappings[0];

            // Act
            gameState.OccupyTile(mapping);

            // Assert
            Assert.AreEqual(gameState.CurrentPlayer, gameState.SecondPlayer);
            Assert.IsTrue(gameState.GameBoard.IsTileOccupied(mapping.TileX, mapping.TileY));
        }

        [Test, Category("valid")]
        public void OccupyTile_InvokeGameOverPlayerWonIfPlayerWon()
        {
            // Arrange
            ButtonTileMapping[] mappings = new ButtonTileMapping[]
            {
                buttonTileMappings[0],
                buttonTileMappings[1],
                buttonTileMappings[2]
            };

            // Act
            foreach (var mapping in mappings)
            {
                gameState.OccupyTile(mapping);
            }

            // Assert
            Assert.IsTrue(gameState.GameBoard.HasWon(gameState.CurrentPlayer.Id));
        }

        [Test, Category("valid")]
        public void OccupyTile_InvokeGameOverDrawIfAllFieldsOccupied()
        {
            // Arrange
            ButtonTileMapping[] mappings = new ButtonTileMapping[]
            {
                buttonTileMappings[0],
                buttonTileMappings[1],
                buttonTileMappings[2],
                buttonTileMappings[3],
                buttonTileMappings[4],
                buttonTileMappings[5],
                buttonTileMappings[6],
                buttonTileMappings[7],
                buttonTileMappings[8],
            };

            // Act
            foreach (var mapping in mappings)
            {
                gameState.OccupyTile(mapping);
            }

            // Assert
            Assert.IsTrue(gameState.GameBoard.AreAllFieldsOccupied());
        }

        [Test, Category("valid")]
        public void OccupyTile_InvokeTileAlreadyOccupiedIfTileOccupied()
        {
            // Arrange
            ButtonTileMapping mapping = buttonTileMappings[0];
            gameState.OccupyTile(mapping);

            EventHandler<EventArgs> eventHandler = (s, e) => { };

            // Act
            gameState.TileAlreadyOccupied += eventHandler;
            gameState.OccupyTile(mapping);

            // Assert
            Assert.Contains(eventHandler, gameState.TileAlreadyOccupied.GetInvocationList());
        }
    }
}
