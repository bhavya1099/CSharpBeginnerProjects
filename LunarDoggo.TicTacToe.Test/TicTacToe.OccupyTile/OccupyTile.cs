// ********RoostGPT********
/*
Test generated by RoostGPT for test java-customannotation-test using AI Type  and AI Model 

ROOST_METHOD_HASH=OccupyTile_93382c77ca
ROOST_METHOD_SIG_HASH=OccupyTile_992d29020a

   ########## Test-Scenarios ##########  

Scenario 1: Occupy an unoccupied tile successfully

Details:
  TestName: OccupyUnoccupiedTileSuccessfully
  Description: This test will verify that the OccupyTile method allows a player to occupy an unoccupied tile and returns true.

Execution:
  Arrange: Instantiate the GameBoard and a Player object. Select coordinates (x, y) of a tile that is currently unoccupied.
  Act: Call the OccupyTile method with the player and the coordinates.
  Assert: Check that the method returns true.

Validation:
  This assertion verifies that a tile can be occupied if it is not already taken. This is essential to ensure players can make valid moves on the board.

---

Scenario 2: Attempt to occupy an already occupied tile

Details:
  TestName: OccupyAlreadyOccupiedTile
  Description: This test checks whether the OccupyTile method returns false when a player tries to occupy a tile that is already occupied.

Execution:
  Arrange: Initialize the GameBoard and two Player objects. Use the first Player to occupy a tile at position (x, y). Then try to occupy the same tile with the second Player.
  Act: Call the OccupyTile method twice, first with the first player, then with the second player on the same tile.
  Assert: Check that the method returns false the second time.

Validation:
  The test confirms that the method correctly prevents a tile from being occupied twice, maintaining game integrity and rule enforcement.

---

Scenario 3: OccupyTile triggers PlayerOccupiedTile event

Details:
  TestName: OccupyTileTriggersPlayerOccupiedTileEvent
  Description: Verify that the PlayerOccupiedTile event is triggered when a tile is successfully occupied by a player.

Execution:
  Arrange: Create a GameBoard instance and a Player object. Subscribe to the PlayerOccupiedTile event. Choose coordinates (x, y) for an unoccupied tile.
  Act: Occupy the chosen tile using the OccupyTile method.
  Assert: Check that the PlayerOccupiedTile event is fired with the correct arguments (player, x, y).

Validation:
  The assertion aims to ensure the event system works correctly, notifying other components of the game state changes, which is crucial for a responsive and interactive game environment.

---

Scenario 4: OccupyTile with invalid coordinates

Details:
  TestName: OccupyTileWithInvalidCoordinates
  Description: Tests that the OccupyTile method handles invalid tile coordinates gracefully, possibly by throwing an exception or handling the error.

Execution:
  Arrange: Set up a GameBoard and a Player object. Define coordinates (x, y) that are outside the valid range (e.g., -1, 3).
  Act: Try to invoke the OccupyTile method with the out-of-range coordinates.
  Assert: Expected handling of the error, such as catching an exception if one is thrown.

Validation:
  This ensures the method is robust against invalid input, preventing crashes or undefined behavior under erroneous conditions.

---

Scenario 5: OccupyTile after game board reset

Details:
  TestName: OccupyTileAfterGameBoardReset
  Description: Checks if a player can occupy a tile that had been previously occupied but reset in the meantime.

Execution:
  Arrange: Initialize the GameBoard, occupy a tile with any Player, and subsequently reset the board.
  Act: Occupy the same tile again after the reset.
  Assert: Verify that the occupation is successful and true is returned.

Validation:
  Ensures that the game board reset functionality correctly clears all tiles, enabling them to be reoccupied, supporting game replayability without manual intervention.



*/

// ********RoostGPT********
using NUnit.Framework;
using Moq;
using System;
using TicTacToe;

namespace TicTacToe.Test
{
    [TestFixture]
    public class OccupyTileTest
    {
        private GameBoard _board;
        private Player _player1;
        private Player _player2;

        [SetUp]
        public void Setup()
        {
            _board = new GameBoard();
            _player1 = new Player(1, "X");
            _player2 = new Player(2, "O");
        }

        [Test, Category("valid")]
        public void OccupyUnoccupiedTileSuccessfully()
        {
            bool result = _board.OccupyTile(_player1, 0, 0);
            Assert.IsTrue(result);
        }

        [Test, Category("valid")]
        public void OccupyAlreadyOccupiedTile()
        {
            _board.OccupyTile(_player1, 0, 0);
            bool result = _board.OccupyTile(_player2, 0, 0);
            Assert.IsFalse(result);
        }

        [Test, Category("integration")]
        public void OccupyTileTriggersPlayerOccupiedTileEvent()
        {
            var mockEventHandler = new Mock<EventHandler<PlayerTileEventArgs>>();
            _board.PlayerOccupiedTile += mockEventHandler.Object;

            _board.OccupyTile(_player1, 0, 0);

            mockEventHandler.Verify(handler => handler(
                It.IsAny<object>(),
                It.Is<PlayerTileEventArgs>(
                    args => args.Player == _player1 && args.TileX == 0 && args.TileY == 0)),
                Times.Once);
        }

        [Test, Category("invalid")]
        public void OccupyTileWithInvalidCoordinates()
        {
            Assert.Throws<IndexOutOfRangeException>(() => _board.OccupyTile(_player1, -1, 3));
        }

        [Test, Category("valid")]
        public void OccupyTileAfterGameBoardReset()
        {
            _board.OccupyTile(_player1, 0, 0);
            _board.Reset();
            bool result = _board.OccupyTile(_player1, 0, 0);
            Assert.IsTrue(result);
        }
    }

    public class PlayerTileEventArgs : EventArgs
    {
        public PlayerTileEventArgs(Player player, int tileX, int tileY)
        {
            Player = player;
            TileX = tileX;
            TileY = tileY;
        }
        public Player Player { get; }
        public int TileX { get; }
        public int TileY { get; }
    }

    public class Player
    {
        public Player(byte id, string display)
        {
            Id = id;
            Display = display;
        }
        public byte Id { get; }
        public string Display { get; }
    }

    public class GameBoard
    {
        public event EventHandler<PlayerTileEventArgs> PlayerOccupiedTile;
        private byte[,] tiles = new byte[3, 3];

        public bool OccupyTile(Player player, int x, int y)
        {
            if (IsTileOccupied(x, y))
            {
                return false;
            }

            tiles[x, y] = player.Id;
            PlayerOccupiedTile?.Invoke(this, new PlayerTileEventArgs(player, x, y));
            return true;
        }

        public void Reset()
        {
            tiles = new byte[3, 3];
        }

        private bool IsTileOccupied(int x, int y)
        {
            return tiles[x, y] != 0;
        }
    }
}
