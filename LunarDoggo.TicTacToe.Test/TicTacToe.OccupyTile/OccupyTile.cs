// ********RoostGPT********
/*
Test generated by RoostGPT for test java-customannotation-test using AI Type  and AI Model 

ROOST_METHOD_HASH=OccupyTile_93382c77ca
ROOST_METHOD_SIG_HASH=OccupyTile_992d29020a

   ########## Test-Scenarios ##########  

Scenario 1: Occupy an unoccupied tile successfully

Details:
  TestName: OccupyUnoccupiedTileSuccessfully
  Description: This test will verify that the OccupyTile method allows a player to occupy an unoccupied tile and returns true.

Execution:
  Arrange: Instantiate the GameBoard and a Player object. Select coordinates (x, y) of a tile that is currently unoccupied.
  Act: Call the OccupyTile method with the player and selected coordinates.
  Assert: Check that the method returns true.

Validation:
  This assertion verifies that a tile can be occupied if it is not already taken. This is essential to ensure players can make valid moves on the board.

---

Scenario 2: Attempt to occupy an already occupied tile

Details:
  TestName: OccupyAlreadyOccupiedTile
  Description: This test checks whether the OccupyTile method returns false when a player tries to occupy a tile that is already occupied.

Execution:
  Arrange: Initialize the GameBoard and two Player objects. Use the first Player to occupy a tile at position (x, y). Then try to occupy the same tile with the second Player.
  Act: Call the OccupyTile method twice, first with the first player, then with the second player on the same tile.
  Assert: Check that the method returns false the second time.

Validation:
  The test confirms that the method correctly prevents a tile from being occupied twice, maintaining game integrity and rule enforcement.

---

Scenario 3: Test event firing upon successful tile occupation

Details:
  TestName: VerifyEventFiresOnSuccessfulOccupation
  Description: This test makes sure that the PlayerOccupiedTile event is triggered when a tile is successfully occupied by a player.

Execution:
  Arrange: Set up the GameBoard and a Player. Attach an event handler to the PlayerOccupiedTile event to track if it fires.
  Act: Occupy a tile using the OccupyTile method.
  Assert: The event handler is invoked.

Validation:
  Ensuring that the PlayerOccupiedTile event is fired upon successful tile occupation is critical for allowing other components of the system to react to gameplay changes, such as updating UI elements or logging activity.

---

Scenario 4: Validate coordinates within bounds

Details:
  TestName: ValidateCoordinatesWithinBounds
  Description: Validates that the OccupyTile method correctly checks that the provided coordinates are within the allowable boundaries of the game board.

Execution:
  Arrange: Create a GameBoard instance and a Player object. Define out-of-bound coordinates like (3, 3) or (-1, 0).
  Act: Attempt to occupy a tile using the out-of-bound coordinates.
  Assert: Functionality should ensure coordinates validity and potentially handle or ignore invalid inputs.

Validation:
  This test is vital to prevent runtime errors due to indexing issues that can occur if coordinates outside of the valid game board dimensions are used.

---

Scenario 5: Player null handling

Details:
  TestName: HandleNullPlayerInput
  Description: Ensures the OccupyTile method gracefully handles scenarios where the Player parameter is null.

Execution:
  Arrange: Create an instance of GameBoard without initializing a Player object. Specify any valid board coordinates (x, y).
  Act: Attempt to occupy a tile providing a null Player.
  Assert: Properly handle the null condition, potentially rejecting the move or throwing an informative exception.

Validation:
  This scenario tests the method's robustness in handling invalid inputs, ensuring that the software behaves predictably and securely when faced with unexpected conditions.


*/

// ********RoostGPT********
using NUnit.Framework;
using System;
using TicTacToe;

namespace TicTacToe.Tests
{
    [TestFixture]
    public class OccupyTileTest
    {
        private GameBoard _gameBoard;
        private Player _player1;
        private Player _player2;

        [SetUp]
        public void Setup()
        {
            _gameBoard = new GameBoard();
            _player1 = new Player(1, "X");
            _player2 = new Player(2, "O");
            _gameBoard.Reset();
        }

        [Test, Category("valid")]
        public void OccupyUnoccupiedTileSuccessfully()
        {
            var result = _gameBoard.OccupyTile(_player1, 0, 0);
            Assert.IsTrue(result);
        }

        [Test, Category("invalid")]
        public void OccupyAlreadyOccupiedTile()
        {
            _gameBoard.OccupyTile(_player1, 0, 0);
            var result = _gameBoard.OccupyTile(_player2, 0, 0);
            Assert.IsFalse(result);
        }

        [Test, Category("valid")]
        public void VerifyEventFiresOnSuccessfulOccupation()
        {
            bool eventFired = false;
            _gameBoard.PlayerOccupiedTile += (sender, args) =>
            {
                eventFired = true;
            };
            _gameBoard.OccupyTile(_player1, 0, 0);
            Assert.IsTrue(eventFired);
        }

        [Test, Category("boundary")]
        public void ValidateCoordinatesWithinBounds()
        {
            var ex1 = Assert.Throws<IndexOutOfRangeException>(() => _gameBoard.OccupyTile(_player1, 3, 3));
            var ex2 = Assert.Throws<IndexOutOfRangeException>(() => _gameBoard.OccupyTile(_player1, -1, 0));
            Assert.That(ex1, Is.InstanceOf<IndexOutOfRangeException>());
            Assert.That(ex2, Is.InstanceOf<IndexOutOfRangeException>());
        }

        [Test, Category("invalid")]
        public void HandleNullPlayerInput()
        {
            var ex = Assert.Throws<ArgumentNullException>(() => _gameBoard.OccupyTile(null, 0, 0));
            Assert.That(ex.ParamName, Is.EqualTo("player"));
        }
    }
}
