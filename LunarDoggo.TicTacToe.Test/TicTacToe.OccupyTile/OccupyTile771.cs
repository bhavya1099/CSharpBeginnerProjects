// ********RoostGPT********
/*
Test generated by RoostGPT for test csharp-test using AI Type  and AI Model 

ROOST_METHOD_HASH=OccupyTile_9e22e63103
ROOST_METHOD_SIG_HASH=OccupyTile_73b7c8d7ca

   ########## Test-Scenarios ##########  

Scenario 1: Test for successful tile occupation
Details:
  TestName: TestOccupationSuccess
  Description: This test is meant to check if the OccupyTile method successfully allows a player to occupy a tile if it's not already occupied.
Execution:
  Arrange: Create an instance of GameState and ButtonTileMapping. The chosen tile should be unoccupied.
  Act: Invoke the OccupyTile method with the created ButtonTileMapping instance.
  Assert: Check if the tile has been occupied by the current player.
Validation:
  The assertion verifies if the tile occupation was successful. The expected result is that the tile is now occupied by the current player. This test is significant as it validates the main functionality of the OccupyTile method.

Scenario 2: Test for unsuccessful tile occupation when the tile is already occupied
Details:
  TestName: TestOccupationFailureTileOccupied
  Description: This test is meant to check if the OccupyTile method prevents a player from occupying a tile if it's already occupied.
Execution:
  Arrange: Create an instance of GameState and ButtonTileMapping. The chosen tile should be already occupied.
  Act: Invoke the OccupyTile method with the created ButtonTileMapping instance.
  Assert: Check if the tile's occupant has not changed.
Validation:
  The assertion verifies if the tile occupation was unsuccessful. The expected result is that the tile's occupant has not changed. This test is significant as it validates the error handling of the OccupyTile method, ensuring that a player cannot occupy an already occupied tile.

Scenario 3: Test for switching players after successful tile occupation
Details:
  TestName: TestPlayerSwitchAfterOccupation
  Description: This test is meant to check if the current player is switched after a successful tile occupation.
Execution:
  Arrange: Create an instance of GameState and ButtonTileMapping. The chosen tile should be unoccupied.
  Act: Invoke the OccupyTile method with the created ButtonTileMapping instance.
  Assert: Check if the current player has been switched.
Validation:
  The assertion verifies if the current player was switched after a successful tile occupation. The expected result is that the current player is now the other player. This test is significant as it validates the game flow, ensuring that turns are alternated between players.

Scenario 4: Test for successful game over due to a player winning
Details:
  TestName: TestGameOverPlayerWon
  Description: This test is meant to check if the game is successfully declared over when a player has won.
Execution:
  Arrange: Create an instance of GameState and ButtonTileMapping. The game state should be such that the current player will win after the next tile occupation.
  Act: Invoke the OccupyTile method with the created ButtonTileMapping instance.
  Assert: Check if the game is declared over due to a player winning.
Validation:
  The assertion verifies if the game was declared over due to a player winning. The expected result is that the game is over and the winning player is the current player. This test is significant as it validates the game's win condition.

Scenario 5: Test for successful game over due to a draw
Details:
  TestName: TestGameOverDraw
  Description: This test is meant to check if the game is successfully declared over when a draw occurs.
Execution:
  Arrange: Create an instance of GameState and ButtonTileMapping. The game state should be such that a draw will occur after the next tile occupation.
  Act: Invoke the OccupyTile method with the created ButtonTileMapping instance.
  Assert: Check if the game is declared over due to a draw.
Validation:
  The assertion verifies if the game was declared over due to a draw. The expected result is that the game is over and no player has won. This test is significant as it validates the game's draw condition.


*/

// ********RoostGPT********
using System;
using System.Linq;
using NUnit.Framework;
using Moq;
using TicTacToe;

namespace TicTacToe.Test
{
    [TestFixture]
    public class OccupyTile771Test
    {
        [Test, Category("valid")]
        public void TestOccupationSuccess()
        {
            // Arrange
            var gameState = new GameState(new ButtonTileMapping[] {});
            var mapping = new ButtonTileMapping(null, 0, 0);

            // Act
            gameState.OccupyTile(mapping);

            // Assert
            Assert.AreEqual(gameState.currentPlayer, mapping.Button.Content);
        }

        [Test, Category("invalid")]
        public void TestOccupationFailureTileOccupied()
        {
            // Arrange
            var gameState = new GameState(new ButtonTileMapping[] {});
            var mapping = new ButtonTileMapping(null, 0, 0);
            gameState.OccupyTile(mapping); // occupy the tile first time

            // Act
            gameState.OccupyTile(mapping); // try to occupy the tile second time

            // Assert
            Assert.AreNotEqual(gameState.currentPlayer, mapping.Button.Content);
        }

        [Test, Category("valid")]
        public void TestPlayerSwitchAfterOccupation()
        {
            // Arrange
            var gameState = new GameState(new ButtonTileMapping[] {});
            var mapping = new ButtonTileMapping(null, 0, 0);
            var firstPlayer = gameState.currentPlayer;

            // Act
            gameState.OccupyTile(mapping);

            // Assert
            Assert.AreNotEqual(firstPlayer, gameState.currentPlayer);
        }

        [Test, Category("valid")]
        public void TestGameOverPlayerWon()
        {
            // Arrange
            var gameState = new GameState(new ButtonTileMapping[] {});
            var mapping = new ButtonTileMapping(null, 0, 0);
            var currentPlayer = gameState.currentPlayer;

            // Act
            gameState.OccupyTile(mapping);

            // Assert
            Assert.IsTrue(gameState.gameBoard.HasWon(currentPlayer.Id));
        }

        [Test, Category("valid")]
        public void TestGameOverDraw()
        {
            // Arrange
            var gameState = new GameState(new ButtonTileMapping[] {});
            var mapping = new ButtonTileMapping(null, 0, 0);

            // Act
            gameState.OccupyTile(mapping);

            // Assert
            Assert.IsTrue(gameState.gameBoard.AreAllFieldsOccupied());
        }
    }
}
