// ********RoostGPT********
/*
Test generated by RoostGPT for test java-customannotation-test using AI Type  and AI Model 

ROOST_METHOD_HASH=Reset_6d2e689bc2
ROOST_METHOD_SIG_HASH=Reset_d971311384

   ########## Test-Scenarios ##########  

Scenario 1: Verify Reset Completes Successfully on an Initially Filled Board

Details:
  TestName: TestResetOnInitiallyFilledBoard
  Description: Checks whether the Reset method successfully resets all tiles to 0 on a board that initially has all tiles occupied by players. 
Execution:
  Arrange: Create a GameBoard instance and fill all the tiles with non-zero values (simulating player moves).
  Act: Invoke the Reset method on the GameBoard instance.
  Assert: Verify that all tiles are reset to 0.
Validation:
  Verify that each element of the tiles array is 0 after Reset() is called. This ensures that the reset functionality correctly prepares the board for a new game. It is critical for gameplay, ensuring that users start from a clear state.

Scenario 2: Verify Reset Completes Successfully on a Partially Filled Board

Details:
  TestName: TestResetOnPartiallyFilledBoard
  Description: Ensures the Reset method correctly clears a board that is partially filled with some player moves.
Execution:
  Arrange: Create a GameBoard instance, fill some tiles with player IDs (not all, to remain partially filled).
  Act: Invoke the Reset method.
  Assert: Check all tiles to confirm they are set to 0.
Validation:
  Asserts that all tiles are zero to ensure that partial games can be effectively cleared out. This confirms that Reset can handle any board state, which is essential after a game interruption or before starting a new session.

Scenario 3: Verify Reset Completeness on an Empty Board

Details:
  TestName: TestResetOnEmptyBoard
  Description: Tests if the Reset method on an already empty board (where no tiles have been occupied) maintains all tiles at 0.
Execution:
  Arrange: Create a new GameBoard instance where no tiles have been modified.
  Act: Call the Reset method.
  Assert: Confirm that all tiles are 0.
Validation:
  Ensures that the Reset method causes no side effects or erroneous behavior when called on a board that is already in the initial state. This test affirms idempotence of the Reset method.

Scenario 4: Verify Reset Method Performance for Consecutive Calls

Details:
  TestName: TestConsecutiveResetsOnGameBoard
  Description: Verifies the stability and consistency of the Reset method when called multiple times consecutively.
Execution:
  Arrange: Initialize a GameBoard and perform some tile occupations.
  Act: Execute the Reset method multiple times (e.g., three successive calls).
  Assert: Each time, verify that all tiles remain at 0 after each reset.
Validation:
  Assesses the method's reliability and stability under repetitive use. This scenario is important to ensure the Reset function's robustness through continuous gameplay sessions.

By exploring these scenarios, we examine the Reset method's behavior under typical conditions, ensuring it works reliably regardless of prior board state, which is fundamental for resetting game progress and ensuring consistent gameplay.


*/

// ********RoostGPT********
using NUnit.Framework;
using TicTacToe;
using System;

namespace TicTacToe.Test
{
    [TestFixture]
    public class ResetTest
    {
        private GameBoard gameBoard;

        [SetUp]
        public void Setup()
        {
            gameBoard = new GameBoard();
        }

        [Test, Category("valid")]
        public void TestResetOnInitiallyFilledBoard()
        {
            // Arrange
            FillAllTiles(gameBoard);

            // Act
            gameBoard.Reset();

            // Assert
            Assert.IsTrue(AllTilesAreReset(gameBoard), "Tiles should all be reset to 0.");
        }

        [Test, Category("valid")]
        public void TestResetOnPartiallyFilledBoard()
        {
            // Arrange
            gameBoard.OccupyTile(new Player(1, "X"), 1, 1);
            gameBoard.OccupyTile(new Player(2, "O"), 2, 2);

            // Act
            gameBoard.Reset();

            // Assert
            Assert.IsTrue(AllTilesAreReset(gameBoard), "Tiles should all be reset to 0.");
        }

        [Test, Category("valid")]
        public void TestResetOnEmptyBoard()
        {
            // Arrange - board is initially empty

            // Act
            gameBoard.Reset();

            // Assert
            Assert.IsTrue(AllTilesAreReset(gameBoard), "Tiles should all be 0.");
        }

        [Test, Category("valid")]
        public void TestConsecutiveResetsOnGameBoard()
        {
            // Arrange
            FillAllTiles(gameBoard);

            // Act and Assert
            for (int i = 0; i < 3; i++)
            {
                gameBoard.Reset();
                Assert.IsTrue(AllTilesAreReset(gameBoard), $"Reset failed on iteration {i + 1}");
            }
        }

        private bool AllTilesAreReset(GameBoard board)
        {
            byte[,] tiles = board.GetTilesForTesting(); // TODO: this method should be added to GameBoard to access tiles.
            for (int x = 0; x < tiles.GetLength(0); x++)
            {
                for (int y = 0; y < tiles.GetLength(1); y++)
                {
                    if (tiles[x, y] != 0)
                        return false;
                }
            }
            return true;
        }

        private void FillAllTiles(GameBoard board)
        {
            for (int x = 0; x < 3; x++)
            {
                for (int y = 0; y < 3; y++)
                {
                    // Rotating player IDs: 1 or 2
                    byte playerID = (byte)((x + y) % 2 + 1);
                    board.OccupyTile(new Player(playerID, playerID == 1 ? "X" : "O"), x, y);
                }
            }
        }
    }
}
