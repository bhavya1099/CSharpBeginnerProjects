// ********RoostGPT********
/*
Test generated by RoostGPT for test java-customannotation-test using AI Type  and AI Model 

ROOST_METHOD_HASH=StartGame_ea5458875f
ROOST_METHOD_SIG_HASH=StartGame_941d5801f0

   ########## Test-Scenarios ##########  

Scenario 1: StartGame Resets The Game Successfully

Details:
  TestName: StartGameResetsGameSuccessfully
  Description: Verify that when StartGame is called, it resets the game board and sets the current player to the first player.
Execution:
  Arrange: Create an instance of GameState with initialized players and game board.
  Act: Invoke the StartGame method on the GameState instance.
  Assert: Check that the currentPlayer is set to firstPlayer, and check that the game board is reset to its initial state.
Validation:
  This assertion verifies that the game correctly resets allowing a new game to start from a clean state. Ensuring the current player is set correctly initiates the game with the correct player's turn.

Scenario 2: TilesReset Event Is Fired On Game Start

Details:
  TestName: TilesResetEventFiredOnGameStart
  Description: Ensures that the TilesReset event is triggered when StartGame method is called, indicating the UI and other components should reset their visuals or states.
Execution:
  Arrange: Create an instance of GameState, subscribe to the TilesReset event with a listener that sets a flag.
  Act: Call StartGame method.
  Assert: Check that the flag is set, indicating that the TilesReset event was fired.
Validation:
  This test confirms that TilesReset event is fired correctly, which is crucial for the UI to update and reflect the reset state of the game board, ensuring the user sees the correct game state at the start of each game.

Scenario 3: StartGame Reinitializes CurrentPlayer To FirstPlayer Regardless Of Previous State

Details:
  TestName: StartGameSetsCurrentPlayerToFirstPlayer
  Description: Test to ensure that StartGame sets currentPlayer to firstPlayer even if the previous current player was secondPlayer.
Execution:
  Arrange: Set up GameState with currentPlayer as secondPlayer.
  Act: Execute the StartGame method.
  Assert: Assert that currentPlayer is now set to firstPlayer.
Validation:
  This helps ensure that no matter the state of the game before restarting, starting a new game always begins with the first player, maintaining the consistency and fairness of game rules.

Scenario 4: StartGame Resets Game Board Correctly

Details:
  TestName: StartGameResetsGameBoardCorrectly
  Description: Ensure that the StartGame method effectively resets the internal state of the game board to its initial configuration where all tiles are unoccupied.
Execution:
  Arrange: Initialize GameState and simulate some plays to alter GameStateâ€™s gameBoard.
  Act: Invoke StartGame.
  Assert: Check each tile in gameBoard to ensure all are in their initial unoccupied state.
Validation:
  This ensures that the game board is correctly cleared of all moves, which is fundamental to starting a new game in an expected clean state. This aspect is vital from both a gameplay and user experience standpoint.

Scenario 5: Persistent Players After Game Reset

Details:
  TestName: PersistentPlayersAfterGameReset
  Description: Verify that player instances (firstPlayer and secondPlayer) remain unchanged after game reset via StartGame.
Execution:
  Arrange: Capture references to firstPlayer and secondPlayer before game reset.
  Act: Call StartGame.
  Assert: Compare initial player references to currentPlayer and validate they match appropriately.
Validation:
  Ensures that player consistency is maintained across game resets, which is essential for game continuity and integrity, especially in environments where player-specific data needs persisting. This ensures no unintended side-effects like reinitialization of player specifics occur on game restarts.


*/

// ********RoostGPT********
using NUnit.Framework;
using System;
using TicTacToe;
using System.Windows.Controls;

namespace TicTacToe.Test
{
    [TestFixture]
    public class StartGameTest
    {
        private GameState gameState;
        private Player firstPlayer;
        private Player secondPlayer;

        [SetUp]
        public void Setup()
        {
            var button = new Button();
            var mappings = new[] { new ButtonTileMapping(button, 0, 0) };

            gameState = new GameState(mappings);
            firstPlayer = new Player(1, "X");
            secondPlayer = new Player(2, "O");
        }

        [Test, Category("valid")]
        public void StartGameResetsGameSuccessfully()
        {
            gameState.StartGame();

            Assert.AreEqual(firstPlayer.Id, gameState.GetCurrentPlayer().Id);
            Assert.IsTrue(gameState.IsBoardReset());
        }

        [Test, Category("valid")]
        public void TilesResetEventFiredOnGameStart()
        {
            bool eventFired = false;
            gameState.TilesReset += (sender, args) => { eventFired = true; };
            
            gameState.StartGame();

            Assert.IsTrue(eventFired);
        }

        [Test, Category("valid")]
        public void StartGameSetsCurrentPlayerToFirstPlayer()
        {
            gameState.SetCurrentPlayer(secondPlayer);
            gameState.StartGame();

            Assert.AreEqual(firstPlayer.Id, gameState.GetCurrentPlayer().Id);
        }

        [Test, Category("valid")]
        public void StartGameResetsGameBoardCorrectly()
        {
            gameState.OccupyTile(new ButtonTileMapping(new Button(), 1, 1)); // Simulate a move
            gameState.StartGame();

            Assert.IsTrue(gameState.IsBoardReset());
        }

        [Test, Category("valid")]
        public void PersistentPlayersAfterGameReset()
        {
            Player originalFirstPlayer = gameState.GetFirstPlayer();
            Player originalSecondPlayer = gameState.GetSecondPlayer();

            gameState.StartGame();

            Assert.AreEqual(originalFirstPlayer.Id, gameState.GetFirstPlayer().Id);
            Assert.AreEqual(originalSecondPlayer.Id, gameState.GetSecondPlayer().Id);
        }
    }
}
