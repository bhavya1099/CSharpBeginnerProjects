// ********RoostGPT********
/*
Test generated by RoostGPT for test java-customannotation-test using AI Type  and AI Model 

ROOST_METHOD_HASH=HasWon_ca2e109cdd
ROOST_METHOD_SIG_HASH=HasWon_c6b52a8205

   ########## Test-Scenarios ##########  

Scenario 1: Player Wins By Completing a Row

Details:
  TestName: TestHasWonWithCompleteRow
  Description: Tests if the HasWon method returns true when a player has all their IDs in a single row.
Execution:
  Arrange: Initialize the game board and occupy an entire row with the same player ID.
  Act: Call the HasWon method with the player ID.
  Assert: Assert that the HasWon method returns true.
Validation:
  The assertion validates that the game correctly identifies a winning condition across a row. This is crucial for the game logic to declare a winner correctly based on the basic rules of TicTacToe.

---

Scenario 2: Player Wins By Completing a Column

Details:
  TestName: TestHasWonWithCompleteColumn
  Description: Tests if the HasWon method returns true when a player has all their IDs in a single column.
Execution:
  Arrange: Set the game board such that a single column is occupied by the same player ID.
  Act: Call the HasWon method with that player ID.
  Assert: Assert that the method returns true.
Validation:
  Validates the game's ability to check vertical winning conditions. This test is important to ensure the game can end correctly when a player achieves a vertical line of tiles.

---

Scenario 3: Player Wins By Completing a Diagonal

Details:
  TestName: TestHasWonWithCompleteDiagonal
  Description: Tests if the HasWon method returns true when a player occupies a diagonal from top-left to bottom-right or top-right to bottom-left.
Execution:
  Arrange: Configure the game board for a diagonal win (either from top-left to bottom-right or vice versa) with a single player ID.
  Act: Invoke the HasWon method for this player ID.
  Assert: The returned value should be true.
Validation:
  Checks if the diagonal checking logic within HasWon is functioning as expected. This scenario is vital since diagonal wins are a standard win condition in TicTacToe.

---

Scenario 4: No Win Condition Met 

Details:
  TestName: TestHasWonWithNoWinningCondition
  Description: Ensure the HasWon method returns false when no win condition is met.
Execution:
  Arrange: Set up the game board with a mix of player IDs that do not fulfill any win conditions.
  Act: Call HasWon for a player.
  Assert: Expect false as a result.
Validation:
  The purpose of this test is to confirm that the game accurately identifies non-winning scenarios. This ensures that the game does not prematurely end or incorrectly assign a winner.

---

Scenario 5: Empty Board Should Not Win

Details:
  TestName: TestHasWonWithEmptyBoard
  Description: Tests that an empty board results in false when checking if a player has won.
Execution:
  Arrange: Ensure the board is reset with no tiles occupied.
  Act: Call the HasWon method for any player ID.
  Assert: Assert that the output is false.
Validation:
  Testing with an empty board checks that the method reliably handles cases where no moves have been made yet, ensuring that the game logic correctly initializes and handles such scenarios.


*/

// ********RoostGPT********
using System;
using NUnit.Framework;
using TicTacToe;

namespace TicTacToe.Test
{
    [TestFixture]
    public class HasWonTest
    {
        private GameBoard _gameBoard;

        [SetUp]
        public void Setup()
        {
            _gameBoard = new GameBoard();
            _gameBoard.Reset();
        }

        [Test, Category("valid")]
        public void TestHasWonWithCompleteRow()
        {
            byte playerId = 1;
            _gameBoard.OccupyTile(new Player(playerId, "X"), 0, 0);
            _gameBoard.OccupyTile(new Player(playerId, "X"), 0, 1);
            _gameBoard.OccupyTile(new Player(playerId, "X"), 0, 2);

            bool result = _gameBoard.HasWon(playerId);

            Assert.True(result);
        }

        [Test, Category("valid")]
        public void TestHasWonWithCompleteColumn()
        {
            byte playerId = 1;
            _gameBoard.OccupyTile(new Player(playerId, "X"), 0, 0);
            _gameBoard.OccupyTile(new Player(playerId, "X"), 1, 0);
            _gameBoard.OccupyTile(new Player(playerId, "X"), 2, 0);

            bool result = _gameBoard.HasWon(playerId);

            Assert.True(result);
        }

        [Test, Category("valid")]
        public void TestHasWonWithCompleteDiagonal()
        {
            byte playerId = 1;
            _gameBoard.OccupyTile(new Player(playerId, "X"), 0, 0);
            _gameBoard.OccupyTile(new Player(playerId, "X"), 1, 1);
            _gameBoard.OccupyTile(new Player(playerId, "X"), 2, 2);

            bool result = _gameBoard.HasWon(playerId);

            Assert.True(result);
        }

        [Test, Category("valid")]
        public void TestHasWonWithNoWinningCondition()
        {
            byte playerId = 1;
            _gameBoard.OccupyTile(new Player(playerId, "X"), 0, 0);
            _gameBoard.OccupyTile(new Player(2, "O"), 0, 1);
            _gameBoard.OccupyTile(new Player(playerId, "X"), 1, 0);
            _gameBoard.OccupyTile(new Player(2, "O"), 1, 2);

            bool result = _gameBoard.HasWon(playerId);

            Assert.False(result);
        }

        [Test, Category("valid")]
        public void TestHasWonWithEmptyBoard()
        {
            byte playerId = 1;

            bool result = _gameBoard.HasWon(playerId);

            Assert.False(result);
        }
    }
}
