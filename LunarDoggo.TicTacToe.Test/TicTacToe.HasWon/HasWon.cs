// ********RoostGPT********
/*
Test generated by RoostGPT for test artilleryTest using AI Type  and AI Model 

ROOST_METHOD_HASH=HasWon_ca2e109cdd
ROOST_METHOD_SIG_HASH=HasWon_c6b52a8205

   ########## Test-Scenarios ##########  

Scenario 1: Player has won in a row

Details:
  TestName: PlayerHasWonInARow
  Description: This test is meant to check if the method correctly identifies that a player has won in a row.
  Execution:
    Arrange: Create a game board with the specified player occupying all three tiles in a row.
    Act: Invoke the HasWon method with the player's ID.
    Assert: Verify that the method returns true.
  Validation:
    The assertion aims to verify that the method correctly identifies that the player has won in a row. This is significant in determining the outcome of the game and declaring the winner.

Scenario 2: Player has won in a column

Details:
  TestName: PlayerHasWonInAColumn
  Description: This test is meant to check if the method correctly identifies that a player has won in a column.
  Execution:
    Arrange: Create a game board with the specified player occupying all three tiles in a column.
    Act: Invoke the HasWon method with the player's ID.
    Assert: Verify that the method returns true.
  Validation:
    The assertion aims to verify that the method correctly identifies that the player has won in a column. This is significant in determining the outcome of the game and declaring the winner.

Scenario 3: Player has won diagonally

Details:
  TestName: PlayerHasWonDiagonally
  Description: This test is meant to check if the method correctly identifies that a player has won diagonally.
  Execution:
    Arrange: Create a game board with the specified player occupying all three tiles in a diagonal.
    Act: Invoke the HasWon method with the player's ID.
    Assert: Verify that the method returns true.
  Validation:
    The assertion aims to verify that the method correctly identifies that the player has won diagonally. This is significant in determining the outcome of the game and declaring the winner.

Scenario 4: Player has not won

Details:
  TestName: PlayerHasNotWon
  Description: This test is meant to check if the method correctly identifies that a player has not won.
  Execution:
    Arrange: Create a game board with no winning combination for the specified player.
    Act: Invoke the HasWon method with the player's ID.
    Assert: Verify that the method returns false.
  Validation:
    The assertion aims to verify that the method correctly identifies that the player has not won. This is significant in determining the outcome of the game and continuing the gameplay.

Scenario 5: Player has won in multiple ways

Details:
  TestName: PlayerHasWonInMultipleWays
  Description: This test is meant to check if the method correctly identifies that a player has won in multiple ways (row, column, and diagonal).
  Execution:
    Arrange: Create a game board with the specified player occupying all three tiles in a row, column, and diagonal.
    Act: Invoke the HasWon method with the player's ID.
    Assert: Verify that the method returns true.
  Validation:
    The assertion aims to verify that the method correctly identifies that the player has won in multiple ways. This is significant in determining the outcome of the game and declaring the winner.

Scenario 6: No player has won

Details:
  TestName: NoPlayerHasWon
  Description: This test is meant to check if the method correctly identifies that no player has won.
  Execution:
    Arrange: Create a game board with no winning combination for any player.
    Act: Invoke the HasWon method with any player's ID.
    Assert: Verify that the method returns false.
  Validation:
    The assertion aims to verify that the method correctly identifies that no player has won. This is significant in determining the outcome of the game and continuing the gameplay.


*/

// ********RoostGPT********
using NUnit.Framework;
using System;

namespace TicTacToe.Test
{
    [TestFixture]
    public class HasWonTest
    {
        private GameBoard gameBoard;

        [SetUp]
        public void Setup()
        {
            this.gameBoard = new GameBoard();
        }

        [Test]
        [Category("valid")]
        public void PlayerHasWonInARow()
        {
            byte player = 1;
            byte[,] winningRowBoard = new byte[3, 3] {
                { player, player, player },
                { 0, 0, 0 },
                { 0, 0, 0 }
            };
            gameBoard.SetTiles(winningRowBoard);

            bool result = gameBoard.HasWon(player);

            Assert.IsTrue(result);
        }

        [Test]
        [Category("valid")]
        public void PlayerHasWonInAColumn()
        {
            byte player = 2;
            byte[,] winningColumnBoard = new byte[3, 3] {
                { 0, player, 0 },
                { 0, player, 0 },
                { 0, player, 0 }
            };
            gameBoard.SetTiles(winningColumnBoard);

            bool result = gameBoard.HasWon(player);

            Assert.IsTrue(result);
        }

        [Test]
        [Category("valid")]
        public void PlayerHasWonDiagonally()
        {
            byte player = 1;
            byte[,] winningDiagonalBoard = new byte[3, 3] {
                { player, 0, 0 },
                { 0, player, 0 },
                { 0, 0, player }
            };
            gameBoard.SetTiles(winningDiagonalBoard);

            bool result = gameBoard.HasWon(player);

            Assert.IsTrue(result);
        }

        [Test]
        [Category("valid")]
        public void PlayerHasNotWon()
        {
            byte player = 2;
            byte[,] nonWinningBoard = new byte[3, 3] {
                { player, 0, 0 },
                { 0, 0, 0 },
                { 0, 0, 0 }
            };
            gameBoard.SetTiles(nonWinningBoard);

            bool result = gameBoard.HasWon(player);

            Assert.IsFalse(result);
        }

        [Test]
        [Category("valid")]
        public void PlayerHasWonInMultipleWays()
        {
            byte player = 1;
            byte[,] multipleWinningBoard = new byte[3, 3] {
                { player, 0, 0 },
                { 0, player, 0 },
                { 0, 0, player }
            };
            gameBoard.SetTiles(multipleWinningBoard);

            bool result = gameBoard.HasWon(player);

            Assert.IsTrue(result);
        }

        [Test]
        [Category("valid")]
        public void NoPlayerHasWon()
        {
            byte player = 1;
            byte[,] noWinningBoard = new byte[3, 3] {
                { player, 0, player },
                { 0, 0, 0 },
                { 0, 0, 0 }
            };
            gameBoard.SetTiles(noWinningBoard);

            bool result = gameBoard.HasWon(player);

            Assert.IsFalse(result);
        }
    }
}
